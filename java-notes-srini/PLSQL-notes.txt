PL/SQL
====================

PL/SQL is a block-structured programming language that combines the data manipulation power of SQL with the processing power of procedural languages. It allows you to:

Write complex business logic

Create reusable code components

Handle errors effectively

Process multiple SQL statements together

Key Features of PL/SQL
=======================

Block Structure
--------------------
--> PL/SQL code is organized in blocks:

DECLARE
    -- Declaration section (variables, constants, cursors)
BEGIN
    -- Execution section (SQL and PL/SQL statements)
EXCEPTION
    -- Exception handling section
END;

--> PL/SQL delivers comprehensive procedural features such as variables, conditional logic, loops, and modular programming constructs. It tightly integrates SQL operations with procedural code and offers robust error handling with both predefined and custom exceptions.

--> We can run PL/SQL directly inside Oracle Database. by using Stored Procedures, Functions, Triggers, Packages.

--> PL/SQL is used to Writing business logic and Validations and data processing and Triggers on tables Automated reporting and batch jobs.



What is a Function in PL/SQL?
==========================================
A function in PL/SQL is a named block that performs a task and returns a single value.


Key Features of PL/SQL Functions
=================================================
--> Every PL/SQL function must return exactly one value using the RETURN statement.

--> Functions can accept IN parameters to perform operations using external input.

--> Once created, functions can be reused in multiple places—inside other PL/SQL blocks, procedures or even SQL statements (if valid).

--> Functions encapsulate logic and improve modularity and readability of your code.

--> Functions that do not modify database state (pure functions) can be called in SELECT, WHERE, ORDER BY, etc.

--> Functions are stored inside the Oracle Database, and can be managed like other database objects (created, altered, dropped).

--> Functions can include EXCEPTION blocks to gracefully handle runtime errors.

--> Improves performance by reducing code duplication and executing logic at the database level.

--> Functions can call other functions or procedures, allowing complex business logic to be broken into smaller components.

--> Functions can return any SQL/PLSQL datatype such as NUMBER, VARCHAR2, DATE, or even custom object types (in advanced use).

Syntax: 

CREATE OR REPLACE FUNCTION function_name (
    param1 [datatype],
    param2 [datatype]  -- Optional parameters
)
RETURN return_datatype
IS
    -- Variable declarations
BEGIN
    -- Function logic
    RETURN value;
END;


Function to Return Area of a Circle
===================================

CREATE OR REPLACE FUNCTION circle_area(radius NUMBER)
RETURN NUMBER
IS
    area NUMBER;
BEGIN
    area := 3.14159 * radius * radius;
    RETURN area;
END;

Call it in PL/SQL block:
==========================
DECLARE
    result NUMBER;
BEGIN
    result := circle_area(5);
    DBMS_OUTPUT.PUT_LINE('Area: ' || result);
END;


Function to Get Employee Full Name
===================================

Assume a table employees(emp_id, first_name, last_name)

CREATE OR REPLACE FUNCTION get_full_name(empid NUMBER)
RETURN VARCHAR2
IS
    full_name VARCHAR2(100);
BEGIN
    SELECT first_name || ' ' || last_name
    INTO full_name
    FROM employees
    WHERE emp_id = empid;

    RETURN full_name;
END;


Function Returning a Fixed Message
===================================

CREATE OR REPLACE FUNCTION welcome_message
RETURN VARCHAR2
IS
BEGIN
    RETURN 'Welcome to PL/SQL Functions!';
END;


BEGIN
    DBMS_OUTPUT.PUT_LINE(welcome_message);
END;



********************Function example in My SQL  ****************

==========================================================================

DELIMITER //

CREATE FUNCTION rectangle_area(length DOUBLE, width DOUBLE)
RETURNS DOUBLE
DETERMINISTIC
BEGIN
    DECLARE area DOUBLE;
    SET area = length * width;
    RETURN area;
END;
//

DELIMITER ;

select rectangle_area(10,5);

 Restrictions of Functions
 ==============================
Functions that modify database state (e.g., insert/update/delete) cannot be used directly in SQL statements.

Only pure functions (no side effects) can be used in SELECT.

===========================

Procedure in pl/sql
===============================

A procedure is a named PL/SQL block that performs a specific task but does not return a value directly (unlike a function).
It may return data indirectly using OUT parameters.


Key Features of PL/SQL Procedures (Theoretical Points)
===========================
Named Subprogram-----------------A procedure is a stored subprogram that performs actions such as inserts, updates, validations, or reports.

May or May Not Accept Parameters-------Procedures can accept:

										IN (input)

										OUT (output)

										IN OUT (read and write) parameters

										Does Not Return a Value Directly

Unlike functions, procedures do not use RETURN to send back a result. They use OUT or IN OUT parameters to return data.

--> Helps organize and modularize complex logic into manageable blocks.

--> Just like functions, procedures are stored in the Oracle database schema.

--> Can be reused and called from: Other procedures,Functions,Triggers,Applications.

--> Includes EXCEPTION blocks to handle errors gracefully.

--> Procedures are commonly used to insert, update, or delete data in tables.

--> Procedures cannot be called directly from SQL SELECT statements, only from PL/SQL blocks or programs.

Syntex: 

CREATE OR REPLACE PROCEDURE procedure_name (
    param1 IN datatype,
    param2 OUT datatype
)
IS
BEGIN
    -- Procedure logic here
END;

Example 1: Simple Procedure (No Parameters)

ex: 
CREATE OR REPLACE PROCEDURE greet_user IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello, welcome to PL/SQL!');
END;

✅ Call the procedure:

BEGIN
    greet_user;
END;


Example 2: Procedure with Parameters


CREATE OR REPLACE PROCEDURE get_bonus (
    p_salary IN NUMBER,
    p_bonus OUT NUMBER
)
IS
BEGIN
    IF p_salary > 50000 THEN
        p_bonus := 10000;
    ELSE
        p_bonus := 5000;
    END IF;
END;

Call it from an anonymous block:

DECLARE
    bonus NUMBER;
BEGIN
    get_bonus(60000, bonus);
    DBMS_OUTPUT.PUT_LINE('Bonus: ' || bonus);
	
END;


Example 3: Procedure to Insert a Record

CREATE OR REPLACE PROCEDURE add_employee (
    p_id IN NUMBER,
    p_name IN VARCHAR2,
    p_dept IN VARCHAR2
)
IS
BEGIN
    INSERT INTO employees (emp_id, name, department)
    VALUES (p_id, p_name, p_dept);
END;


ex:



DELIMITER $$

CREATE PROCEDURE GetEmployeesByDept(IN dept_name VARCHAR(50))
BEGIN
    SELECT iD, name, salary
    FROM Employees
    WHERE department = dept_name;
END$$

DELIMITER ;

how to call above procedure
================================
call GetEmployeesByDept('HR');


Bonus: Procedure with OUT Parameter
Here's another example that returns the average salary for a department using an OUT parameter:
==================================================================================================

DELIMITER $$

CREATE PROCEDURE GetAvgSalaryByDept(
    IN dept_name VARCHAR(50),
    OUT avg_sal DECIMAL(10,2)
)
BEGIN
    SELECT AVG(Salary) INTO avg_sal
    FROM Employees
    WHERE Department = dept_name;
END$$

DELIMITER ;

by using below script we can call procedure
============================================

SET @avg := 0;
CALL GetAvgSalaryByDept('IT', @avg);
SELECT @avg;




What is a Trigger in PL/SQL?
===============================================================================
A trigger is a stored PL/SQL block that is automatically executed (fired) in response to a specific event on a table or view, such as:

INSERT, UPDATE,	DELETE


Trigger Syntax (Row-Level Example)
---------------------------------

CREATE OR REPLACE TRIGGER trigger_name
BEFORE INSERT OR UPDATE OR DELETE ON table_name
FOR EACH ROW
BEGIN
    -- Trigger logic here
END;



Types of Triggers in PL/SQL
=================================
Type								Description
=================================================
BEFORE Trigger				Fires before the DML event
AFTER Trigger				Fires after the DML event
INSTEAD OF Trigger			Used on views to simulate DML
ROW Trigger					Fires once for each row affected
STATEMENT Trigger			Fires once for the whole DML statement


Key Features of Triggers in PL/SQL (Theoretical Points)
=========================================================

-->Triggers are automatically fired by the database in response to DML events like INSERT, UPDATE, or DELETE on a table or view.

-->Triggers are associated with specific events on a table such as:

   BEFORE INSERT, AFTER UPDATE, BEFORE DELETE,
--> Triggers Can Be Row-Level or Statement-Level triggers

		Row-level triggers fire once for each affected row.

		Statement-level triggers fire once per DML operation, regardless of the number of rows affected.

--> Triggers can execute before or after the DML operation, allowing custom logic to validate, block, or audit changes.

--> Triggers are commonly used to track changes, maintain audit logs, and record user actions without modifying application code.

--> Triggers can be used to prevent invalid transactions or to apply custom validations (e.g., salary should not decrease).

--> Inside a trigger body, you can write complex logic or call stored procedures for modular and reusable design.

--> Unlike procedures or functions, triggers cannot be called explicitly. They run only when the defined event occurs.

--> Each trigger is associated with specfic table or view. It executes only when a DML operation happens on that object.

--> Triggers do not accept input parameters — they rely only on the context of the triggering event and row data.



Example: Audit Log on Employee Updates

--------------------------------------
1. Main Table: employees
===========================

CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    salary NUMBER
);


2. Audit Table: employee_audit
===========================


CREATE TABLE employee_audit (
    emp_id NUMBER,
    old_salary NUMBER,
    new_salary NUMBER,
    changed_on DATE
);

3. Trigger: Audit Salary Updates
==============================

CREATE OR REPLACE TRIGGER trg_employee_salary_audit
AFTER UPDATE OF salary ON employees
FOR EACH ROW
BEGIN
    INSERT INTO employee_audit (emp_id, old_salary, new_salary, changed_on)
    VALUES (:OLD.emp_id, :OLD.salary, :NEW.salary, SYSDATE);
END;


How It Works:
			:OLD.salary → Value before update

			:NEW.salary → Value after update

			Trigger fires AFTER every UPDATE on salary column
			
Test the Trigger
=================

-- Insert employee
INSERT INTO employees VALUES (1, 'Alice', 50000);

-- Update salary
UPDATE employees SET salary = 55000 WHERE emp_id = 1;

-- Check audit table
SELECT * FROM employee_audit;


Oracle maintains an internal trigger registry for each table.

When a DML statement is executed, Oracle checks the registry for matching triggers.

If found, Oracle fires the trigger in the defined order (BEFORE → actual DML → AFTER).


Use Cases for Triggers
===================================
Audit and logging

Enforcing business rules (e.g., no salary cuts)

Preventing invalid data entry

Maintaining derived columns

Replicating changes to another table

*******************************************MySQL Triggers*********************8

CREATE TABLE Employees12 (
    EmpID INT PRIMARY KEY AUTO_INCREMENT,
    EmpName VARCHAR(50),
    Department VARCHAR(50),
    Salary DECIMAL(10,2)
);



CREATE TABLE Employee_Audit (
    AuditID INT PRIMARY KEY AUTO_INCREMENT,
    EmpID INT,
    ActionType VARCHAR(10),
    ActionTime DATETIME
);

DELIMITER $$

CREATE TRIGGER before_employee_insert
BEFORE INSERT ON Employees12
FOR EACH ROW
BEGIN
    INSERT INTO Employee_Audit (EmpID, ActionType, ActionTime)
    VALUES (NEW.EmpID, 'INSERT', NOW());
END$$

DELIMITER ;

SELECT * FROM employee_audit;

INSERT INTO Employees12 (EmpName, Department, Salary)
VALUES ('John Doe', 'IT', 65000);

